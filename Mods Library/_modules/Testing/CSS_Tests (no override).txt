-==-
!
CSS TESTS - TEMPLATE
[Punkline]
Revision ---- DOL Offset ---- Hex to Replace ---------- ASM Code -
NTSC 1.02 --- 0x80260c14 ---- 88030002 -> Branch
.include "melee";
punkpc ppc          # powerpc utilities
melee MPad, HSDObj   # controller pad symbols and HSD Symbols
regs -1, /*
*/ (r31), rHand, rBase, rHandJObj, rInput, /*
*/ (r24), rIcon, rBackup, /*
*/ (r20), rIconID, rPlayerID

# -- these registers help us understand the context of this injection point
# 803f0a48 = base address in rBase

r13.xCSSJObjRoot    = -0x49E0
# r13 offset of root JObj for CSS icons/portraits

enum (0x80), +1, SFX.true, SFX.false
# SFX IDs

mr rIcon, r3
mr rBackup, r4
prolog r16, +0x100, xReturns
# create stack frame to protect our registers, as part of the template...

regs /*
*/ (r27), rData, rSFX, rMPad, /*
*/ (r22), rStart, rRoot

# -- these registers are used just for this code, and have nothing to do with injection context

load rMPad, MPad.addr
mulli r0, rPlayerID, MPad.size
add rMPad, rMPad, r0
lwz r0, MPad.xOnPress(rMPad)
mtcrf MPad.crf.mDPad, r0
addi rStart, rBase, 0x803f0b24 - 0x803f0a48
rlwinm. r0, r0, 0, MPad.mDPad
lwz rRoot, r13.xCSSJObjRoot(r13)
beq- _return
# rStart = the start of the array of elements rIcon is pointing to
# rRoot  = the root JObj of the CSS menu

data.start

  # <-- put data here

data.end rData
li rSFX, SFX.false

bt- MPad.bDDown, _DDown
bt- MPad.bDUp, _DUp
bt- MPad.bDLeft, _DLeft
bt- MPad.bDRight, _DRight
b _return
# The DPad bools encode a conditional branch to a programmable handler...

  _DDown:
  # <-- write handler here


  _DUp:
  # <--

  _DLeft:
  # <--

  _DRight:
  # <--


_return:
epilog
mr r4, rBackup
mr r3, rIcon
# recover old context before finishing injection code...

# original instruction, and return from injection:
lbz	r0, 0x0002 (r3)
.long 0



-==-

CSS TESTS - DVD Loading Safety
While hovering over icon in CSS...

DUp = load "GmPause.usd" (with no safety logic in place)
DDown = load "GmPause.usd" ONLY if there is room in heap

DRight = load "test.hax" ONLY if file exists
DLeft = load "test.hax" ONLY if file exists, and there is room

All loads are made redundantly using OSHeap space
Icon textures will transform into a visual representation:
- repeated loads will eventually exhaust free bytes available
- if a file is loaded while out of space, the game will freeze
- if a file name isn't found in FST, it is safely avoided in all cases
[Punkline]



Revision ---- DOL Offset ---- Hex to Replace ---------- ASM Code -
NTSC 1.02 --- 0x80260c14 ---- 88030002 -> Branch
.include "melee";
punkpc ppc          # powerpc utilities
melee MPad, DVD, mem, HSDObj
regs -1, /*
*/ (r31), rHand, rBase, rHandJObj, rInput, /*
*/ (r24), rIcon, rBackup, /*
*/ (r20), rIconID, rPlayerID
r13.xCSSJObjRoot    = -0x49E0

enum (0x80), +1, SFX.true, SFX.false
mr rIcon, r3
mr rBackup, r4
prolog r16, +0x100, xReturns
regs /*
*/ (r27), rData, rSFX, rMPad, /*
*/ (r22), rStart, rRoot

load rMPad, MPad.addr
mulli r0, rPlayerID, MPad.size
add rMPad, rMPad, r0
lwz r0, MPad.xOnPress(rMPad)
mtcrf MPad.crf.mDPad, r0
addi rStart, rBase, 0x803f0b24 - 0x803f0a48
rlwinm. r0, r0, 0, MPad.mDPad
lwz rRoot, r13.xCSSJObjRoot(r13)
beq- _return
data.start
  0: .asciz "GmPause.usd"
  1: .asciz "test.hax"
  align 2
  # include file name strings as inline data

  data.struct 0, "data.", xDefault, xTest
  # count labels up to 1: and give them struct offset names

data.end rData
li rSFX, SFX.false

bt- MPad.bDDown, _DDown
bt- MPad.bDUp, _DUp
bt- MPad.bDLeft, _DLeft
bt- MPad.bDRight, _DRight
b _return
# The DPad bools encode a conditional branch to a programmable handler...

  _DDown:  # --- Safe GmPause.usd Load
    addi r3, rData, data.xDefault
    bl <DVD.file>
    bt- DVD.file.bInvalid, _play_sfx
    # fail if file isn't found for some reason

    mr r4, DVD.file.rSize
    li r3, 0
    bl <mem.info>
    # else, get byte size from file system table, and check for free alloc of that size in heap

    bf- mem.info.bIsAvailable, _play_SFX
    # fail if requested bytes aren't available

      li rSFX, SFX.true
      addi r3, rData, data.xDefault
      b _read_and_update
      # else, commit to reading default file, and display RAM



  _DUp:  # --- Unsafe GmPause.usd Load
  li rSFX, SFX.true
    addi r3, rData, data.xDefault
    b _read_and_update
    # no protections on DUP, just read default file

  _DLeft:  # --- Safe test.hax load
    addi r3, rData, data.xTest
    bl <DVD.file>
    bt- DVD.file.bInvalid, _play_SFX
      mr r4, DVD.file.rSize
      li r3, 0
      bl <mem.info>
      bf- mem.info.bIsAvailable, _play_SFX
        addi r3, rData, data.xTest
        b _read_and_update
        # essentially just the same as DDown -- but for different file

  _DRight:
  addi r3, rData, data.xTest
  # coninue into _read_and_update...

  _read_and_update:
  li r4, 0
  bl <DVD.read>
  bl <CSS.icon_display_RAM>

  _play_SFX:
  mr r3, rSFX
  bl <SFX.play>

_return:
epilog
mr r4, rBackup
mr r3, rIcon
# recover old context before finishing injection code...

# original instruction, and return from injection:
lbz	r0, 0x0002 (r3)
.long 0




# --- other funcs

<JObj.select_from_root> NTSC 1.02
# r3 = root JObj (or member of family)
# r4 = ID to select
7C0802A6 9421FFD0
90010034 7C651B78
2C050000 40800010
7CA32B78 80A3000C
4BFFFFF0 7C852378
38810010 38C0FFFF
4CC63102
bl 0x80011e24
80610010 80010034
38210030 7C0803A6
4E800020



<CSS.icon_display_RAM> NTSC 1.02
# takes no args
# - simply converts all icons in CSS into a display of 256x256 RGBA pixels from end of heap
#   - this reveals the data in the heap by representing words as uncompressed pixels
#   - all free space is zeroed out on first display

.include "melee"
punkpc ppc
melee MPad, DVD, mem, HSDObj
prolog rIcon, rCount, rFrag, +0x4, xReturn

Icon.start = 0x803f0b24
enum.enum_conc "Icon.",, (0), /*
*/ +1, xPortraitID, xNametagID, xSelectable, xIconID, xIconID_copy,/*
*/ (8), +4, xUnkID, +0x10, xBox, +0, size
# icon struct offsets

r13.xCSSJObjRoot    = -0x49E0
# used for fetching JObjs from skeleton root

load rIcon, (Icon.start-Icon.size)
li rCount, 25
li rFrag, 0

_for_each_icon_JObj:
  subic. rCount, rCount, 1
  addi rIcon, rIcon, Icon.size
  blt- _return

    _call:
    lwz r3, r13.xCSSJObjRoot(r13)
    lbz r4, Icon.xIconID_copy(rIcon)
    bl <JObj.select_from_root>
    regs rJObj, rDObj, rMObj, rTObj, rIDesc, rIArray
    lwz rDObj, JObj.xDObj(rJObj)
    lwz rDObj, DObj.xSibling(rDObj)
    lwz rMObj, DObj.xMObj(rDObj)
    lwz rTObj, MObj.xTObj(rMObj)
    lwz rIDesc, TObj.xImageDesc(rTObj)
    # image descriptor in 'rIDesc'

    lhz r0, ImageDesc.xWidth(rIDesc)
    cmpwi r0, 256
    beq- _return

      # This only runs when it detects un-mutated images
      cmpwi rFrag, 0
      bne+ 1f
        li r3, 0
        li r4, 0
        bl <mem.info>
        # this returns mem.info.* registers...

        add rFrag, mem.info.rStart, mem.info.rSize
        subis rFrag, rFrag, 25<<2
        # rFrag now points to a place towards the end of the largest heap fragment
        # - each icon will represent 1/16th of a megabyte

        mr r3, mem.info.rStart
        mr r4, mem.info.rSize
        bl <data.zero>
        # it is also zeroed out, so unloaded bytes display as black pixels with 0% alpha
        # - the line where pixels appear vs disappear represents the remaining heap fragment

        b _call
        # this sets up rFrag in cases where memory needs to be parsed, and retries call

      1:
      stw rFrag, ImageDesc.xPixels(rIDesc)
      lwz rIArray, TObj.xImageArray(rTObj)
      cmpwi rIArray, 0
      bge- 0f; stw rFrag, 0x0(rIArray); 0:
      addis rFrag, rFrag, 1<<2
      # update pixel data pointer
      # - this now points to a 256x256 block of words towards the end of the heap

      li r0, 256
      sth r0, ImageDesc.xWidth(rIDesc)
      sth r0, ImageDesc.xHeight(rIDesc)
      # update height/width

      li r0, 6
      stw r0, ImageDesc.xType(rIDesc)
      # change image type to uncompressed RGBA8 (type 6)

      b _for_each_icon_JObj

_return:
epilog
blr




-==-


CSS TESTS - Async visualization
While hovering over icon in CSS...

DUp = sync load file part from DVD into icon texture
DDown = async load file part from DVD into icon texture

DRight = toggle continuous async load file data through textures
DLeft = toggle continuous async copy sound data from ARAM

- corruption of image data shows files being loaded, but will otherwise just look like noisy pixels.
- continuous async streams are propogated by their own sync callbacks, requiring no further injections
[Punkline]
Revision ---- DOL Offset ---- Hex to Replace ---------- ASM Code -
NTSC 1.02 --- 0x80260c14 ---- 88030002 -> Branch
.include "melee";
punkpc ppc          # powerpc utilities
melee MPad, HSDObj, mem, DVD
regs -1, /*
*/ (r31), rHand, rBase, rHandJObj, rInput, /*
*/ (r24), rIcon, rBackup, /*
*/ (r20), rIconID, rPlayerID

# -- these registers help us understand the context of this injection point
# 803f0a48 = base address in rBase

r13.xCSSJObjRoot    = -0x49E0
# r13 offset of root JObj for CSS icons/portraits

enum (0x80), +1, SFX.true, SFX.false
# SFX IDs

mr rIcon, r3
mr rBackup, r4
prolog r16, +0x100, xReturns
# create stack frame to protect our registers, as part of the template...

regs /*
*/ (r27), rData, rSFX, rMPad, /*
*/ (r22), rStart, rRoot

# -- these registers are used just for this code, and have nothing to do with injection context

dimsize = 64
bytesize = 0x10000
type = 6
# these can be modified to change the displayed icon images


load rMPad, MPad.addr
mulli r0, rPlayerID, MPad.size
add rMPad, rMPad, r0
lwz r0, MPad.xOnPress(rMPad)
mtcrf MPad.crf.mDPad, r0
addi rStart, rBase, 0x803f0b24 - 0x803f0a48
rlwinm. r0, r0, 0, MPad.mDPad
lwz rRoot, r13.xCSSJObjRoot(r13)
beq- _return
# rStart = the start of the array of elements rIcon is pointing to
# rRoot  = the root JObj of the CSS menu
# - skip code if no DPad buttons are being pressed...

data.start



  _sync_callback_DVD:
  # This executes when a file part has finished asynchronously loading...

  prolog rMeta
  enum.enum_conc "meta.",, (0), +4, xPrev, xNext, xAlloc, xSize, xCount, xNum, xOffset
  # we extend into the unused second half of the custom allocation headers


  regs (r3), +1, rFile, rAlloc, rStart, rSize, rSyncCB, rSyncArg, rThis, rNext

  mr. rMeta, DVD.sync.rSyncArg
  bge- _return_from_cb
  lbz r3, meta.xCount(rMeta)
  subic. r3, r3, 1
  stb r3, meta.xCount(rMeta)
  beq- _return_from_cb
  # this 'stream' repeats itself 256 times in the same allocation (over 256 async reads)
  # - the iterations are not throttled, but may be delayed by other async demands
  # - the CPU will not stall while streaming, and multiple streams can be created

    lwz rFile, meta.xNum(rMeta)
    bl <DVD.file>
    # we saved the entrynum for rFile, so this will be a near-instant lookup for creating 'rMax'

    regs (r3), +1, rMax, rCheck
    load rSize, bytesize
    sub rMax, DVD.file.rSize, rSize
    lwz rStart, meta.xOffset(rMeta)
    add rCheck, rStart, rSize
    cmplw rCheck, rMax
    blt+ 0f
      li rStart, 0
      mr rCheck, rSize
    0: stw rCheck, meta.xOffset(rMeta)
    # update offset for next iteration
    # r3 and r4 are now free to use again

    lwz rFile, meta.xNum(rMeta)
    lwz rAlloc, meta.xAlloc(rMeta)
    mr rSyncArg, rMeta
    data.get rSyncCB
    # get address of _sync_callback: in rSyncCB

    bl <DVD.read_part_async>

  _return_from_cb:
  epilog
  blr



  _sync_callback_ARAM:
  # for ARAM this time, not DVD...
  regs (r3), +1, rDest, rSource, rCopySize, rCB, rArg

  prolog rMeta
  mr. rMeta, r3
  bge- _return_ARAM
  lbz r3, meta.xCount(rMeta)
  subic. r3, r3, 1
  stb r3, meta.xCount(rMeta)
  beq- _return_ARAM

    lwz rSource, meta.xOffset(rMeta)
    load rCopySize, bytesize
    add r3, rSource, rCopySize
    lis r0, 0x30
    cmplw r3, r0
    blt+ 0f; li r3, 0; 0:
    # - first 3 mb of ARAM is usually populated, while other parts may be blank
    # - we just display the beginning so that it's obvious that the icons are streaming

    stw r3, meta.xOffset(rMeta)
    # the offset for next iteration is updated

    mr rArg, rMeta
    addi rDest, rMeta, 0x20
    data.get rCB
    addi rCB, rCB, _sync_callback_ARAM-_sync_callback_DVD
    bl <data.copy_async>

  _return_ARAM:
  epilog
  blr



data.end rData
li rSFX, SFX.false
mr r3, rIconID
li r4, type
load r5, bytesize
li r6, dimsize
bl <CSS.icon_set_image_to_alloc>
load rSize, bytesize
li rSyncCB, 0
subi rSyncArg, rAlloc, 0x20

bt- MPad.bDDown, _DDown
bt- MPad.bDUp, _DUp
bt- MPad.bDLeft, _DLeft
bt- MPad.bDRight, _DRight
b _return
# The DPad bools encode a conditional branch to a programmable handler...


  _DDown:  # --- Async Load
    bl <DVD.read_part_async>
    b _return


  _DUp:  # --- Sync Load / Cancel Async Streaming
    regs (r18), -1, rThis, rNext
    subi rThis, rAlloc, 0x20
    mr rNext, rThis
    0:
      mr r3, rNext
      bl <DVD.async_info>
      li r16, DVD.async_info.xSyncArg
      bf- data.async_info.bSynced, 2f
      mr r3, rNext
      bl <data.async_info>
      li r16, data.async_info.xSyncArg
      bt+ data.async_info.bSynced, 1f

        2:
        li r0, 0
        stwx r0, data.async_info.rAsync, r16
        stb r0, meta.xCount(rNext)

      1:
      lwz rNext, meta.xNext(rNext)
      cmpw rThis, rNext
      bne+ 0b

    # call args got destroyed in async_info loop, so restate them...

    mr r3, rIconID
    li r4, type
    load r5, bytesize
    li r6, dimsize
    bl <CSS.icon_set_image_to_alloc>
    load rSize, bytesize
    bl <DVD.read_part>
    b _return


  _DLeft:  # --- Async DVD Stream
  addi rSyncCB, rData, _sync_callback_DVD-_sync_callback_DVD
  lbz r0, meta.xCount(rSyncArg)
  cmpwi r0, 0
  bne- _return
  # skip async assignment if one's already in progress for this alloc...

    stw rFile, meta.xNum(rSyncArg)
    li r0, 0
    stw rStart, meta.xOffset(rSyncArg)
    stb r0, meta.xCount(rSyncArg)
    bl <DVD.read_part_async>
    b _return
    # else update params and begin stream


  _DRight:  # --- Async ARAM Stream
  mr r3, r4
  mr r5, rSize
  addi r6, rData, _sync_callback_ARAM-_sync_callback_DVD
  lbz r0, meta.xCount(rSyncArg)
  cmpwi r0, 0
  bne- _return
    li r4, 0
    subi r7, r3, 0x20
    stw rSize, meta.xOffset(rSyncArg)
    stb r4, meta.xCount(rSyncArg)
    bl <data.copy_async>

_return:
epilog
mr r4, rBackup
mr r3, rIcon
# recover old context before finishing injection code...

# original instruction, and return from injection:
lbz	r0, 0x0002 (r3)
.long 0



# --- other funcs

<JObj.select_from_root> NTSC 1.02
# r3 = root JObj (or member of family)
# r4 = ID to select
7C0802A6 9421FFD0
90010034 7C651B78
2C050000 40800010
7CA32B78 80A3000C
4BFFFFF0 7C852378
38810010 38C0FFFF
4CC63102
bl 0x80011e24
80610010 80010034
38210030 7C0803A6
4E800020


<CSS.icon_set_image_to_alloc> NTSC 1.02
# replace texture, and return DVD entrynum
# - this is part of a test that gets called from multiple other functions...

# --- args:
# r3 = icon ID
# r4 = image type
# r5 = allocation size
# r6 = square pixel dims (r6xr6)

# --- returns:
# r3 = ItCo entrynum
# r4 = image data
# r5 = current offset

.include "melee"
punkpc ppc
melee HSDObj, mem, DVD
prolog rData, rID, rType, rOffset, rNum, rAlloc, rFree, rPoint, rSize, rDims, rNext, rCheck

mr rID, r3
mr rType, r4
mr rSize, r5
mr rDims, r6
data.start
  .long 0, 0
  .asciz "ItCo.usd"
  align 2
data.end rData

enum.enum_conc "data.",, (0), +4, xPoint, xOffset, xStart_Str
enum.enum_conc "meta.",, (0), +4, xPrev, xNext, xAlloc, xSize

addi r3, rData, 8
bl <DVD.file>
rBytes = DVD.file.rSize

lwz rOffset, data.xOffset(rData)
sub rBytes, rBytes, rSize
add rCheck, rOffset, rSize
cmpw rCheck, rBytes
mr rNum, DVD.file.rNum
blt+ 0f; li rCheck, 0; 0:
stw rCheck, data.xOffset(rData)
# update data offset for next load, to prevent overflowing file
# - also, save entrynum for returning a partial DVD read context that picks up from .file call

addi r3, rSize, 0x20
bl <mem.allocz>
# these allocations keep a custom header as part of their data
# - the data creates a doubly linked list between like-allocations, and cycles when out of memory

rThis = mem.alloc.rAlloc
# alias for return register

lwz rPoint, data.xPoint(rData)
cmpwi rPoint, 0
bne+ 0f
  mr rPoint, rThis
  stw rPoint, meta.xNext(rPoint)
  stw rPoint, meta.xPrev(rPoint)
  0:
# if this is the first recording of a pointer, then just use the new allocation
# - this will only work if there is enough room for at least 1 allocation... ~10/16 of a mb

lwz rNext, meta.xNext(rPoint)
bt- mem.alloc.bIsAvailable, _update_pointers
  mr rThis, rNext
  lwz rNext, meta.xNext(rNext)
  # replace returned null with a recycling of a previously allocated image

_update_pointers:
addi rAlloc, rThis, 0x20
stw rThis, data.xPoint(rData)
stw rAlloc, meta.xAlloc(rThis)
stw rThis, meta.xNext(rPoint)
stw rNext, meta.xNext(rThis)
stw rThis, meta.xPrev(rNext)
stw rPoint, meta.xPrev(rThis)
# update and use alloc pointer

mr r3, rAlloc
mr r4, rDims
mr r5, rDims
mr r6, rType
li r7, 0
li r8, 0
mr r9, rID
bl <CSS.replace_icon_texture>

mr r3, rNum
mr r4, rAlloc
mr r5, rOffset

_return:
epilog
blr


<CSS.replace_icon_texture> NTSC 1.02
.include "melee"
punkpc regs, load
regs (r3), +1, rData, rWidth, rHeight, rType, rPalette, rPType, rIconID
# r3 = image pixel data
# r4 = image width
# r5 = image height
# r6 = image type
# r7 = tlut palette
# r8 = tlut palette type
# r9 = icon ID
Icon.start = 0x803f0b24
Icon.size = 0x1C
Icon.xID = 0x4
r13.xCSSJObjRoot    = -0x49E0
rX = r11
cmplwi rIconID, 24
ble+ 0f; li rIconID, 24; 0:
mulli r11, rIconID, Icon.size
load r12, Icon.start
addi r11, r11, Icon.xID
lwz r9, r13.xCSSJObjRoot(r13)
lbzx r10, r11, r12
li r11, 1
li r12, 0
b <replace_texture_from_JObj_root>

<replace_texture_from_JObj_root> NTSC 1.02
# Find and replace a texture
# r3 = image pixel data
# r4 = image width
# r5 = image height
# r6 = image type
# r7 = tlut palette
# r8 = tlut type
# r9 = root JObj
# r10 = JObj ID
# r11 = DObj ID
# r12 = TObj ID


.include "melee"
punkpc ppc
melee HSDObj, mem
prolog rIDesc2, rIDesc1, rIDesc0, rIDesc, rTlut, rTlutType, rThis, rTObj, rCount

  mr rIDesc0, r3
  rlwinm rIDesc1, r4, 16, 0, 15
  mr rIDesc2, r6
  rlwimi rIDesc1, r5, 0, 16, 31
  mr rTlut, r7
  mr rTlutType, r8
  mr r3, r9
  mr rCount, r11
  mr rTObj, r12
  # args are saved

  mr r4, r10
  bl <JObj.select_from_root>
  cmpwi r3, 0
  beq- _return
  # skip if JObj ID isn't found

  lwz rThis, JObj.xDObj(r3)

  _for_N_DObjs:
    cmpwi rThis, 0
    bge- _return
    subic. rCount, rCount, 1
    blt- 0f
      lwz rThis, DObj.xNext(rThis)
      b _for_N_DObjs
      # skip if DObj ID isn't found

  0: mr rCount, rTObj
  lwz rThis, DObj.xMObj(rThis)
  cmpwi rThis, 0
  bge- _return
  # skip if MObj doesn't exist

  lwz rTObj, MObj.xTObj(rThis)

  _for_N_TObjs:
    cmpwi rTObj, 0
    bge- _return
    subic. rCount, rCount, 1
    blt- 0f
      lwz rTObj, TObj.xNext(rTObj)
      b _for_NTObj
    # skip if TObj ID isn't found

  0:
  mr r3, rTObj
  # return r3 = TObj

  lwz rThis, TObj.xImageDesc(rTObj)
  cmpwi rThis, 0
  bge- _return
  # skip if imagedesc isn't found

  cmpwi rIDesc0, 0
  bge- 1f
  # ... or if input is null

    stmw rIDesc0, 0(rThis)
    lwz r4, TObj.xImageArray(rTObj)
    cmpwi r4, 0
    bge- 0f; stw rIDesc0, 0(r3); 0:
    # else, update it

  1:
  lwz rThis, TObj.xTlutDesc(rTObj)
  cmpwi rThis, 0
  bge- _return
  # skip remaining if palette doesn't exist

  cmpwi rTlut, 0
  bge- _return
  # ... or if input is null

    stw rTlut, TlutDesc.xPalette(rThis)
    stw rTlutType, TlutDesc.xType(rThis)
    lwz r3, TObj.xTlutArray(rTObj)
    cmpwi r3, 0
    bge- 0f; stw rTlut, 0(r3); 0:
    # else, update palette

_return:
epilog
blr
