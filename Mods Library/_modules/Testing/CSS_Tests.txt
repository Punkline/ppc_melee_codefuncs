-==-

CSS - Icon selection DPad events
[Punkline]
Revision ---- DOL Offset ---- Hex to Replace ---------- ASM Code -
NTSC 1.02 --- 0x80260c14 ---- 88030002 -> Branch
.include "melee";
punkpc ppc          # powerpc utilities
melee MPad, HSDObj   # controller pad symbols and HSD Symbols


# the 'regs' macro helps us name registers counting up +1 or down +1 from a starting register (rN)

regs -1, /*
*/ (r31), rHand, rBase, rHandJObj, rInput, /*
*/ (r24), rIcon, rBackup, /*
*/ (r20), rIconID, rPlayerID

# -- these registers help us understand the context of this injection point
# 803f0a48 = base address in rBase


r13.xCSSJObjRoot    = -0x49E0
# r13 offset of root JObj for CSS icons/portraits


# code start:

mr rIcon, r3
mr rBackup, r4
# back these up for now, so that we don't disrupt the normal game program
# - the assigned registers in the above 'regs' call puts these in a safe place

load r4, MPad.addr
mulli r0, rPlayerID, MPad.size
add r4, r4, r0
lwz r0, MPad.xOnPress(r4)
mtcrf MPad.crf.mDPad, r0
# We can check DPad button presses from the Master Pad .xOnPress bool field
# - loading it into cr directly lets us use the bools without having to compare anything

# We can use these bools to 'call' custom code based on whether or not the bits are True
# Once the custom code is finished, it will 'return' back to the place it was called from

# Registers r3 ... r12 may be used to safely 'pass' information to our called code

# Currently, we have the following set up:
# r3 = rIcon -- a descriptor that keeps vars for the icon currently being hovered over by cursor
# r4 = rMPad -- the master pad struct for this player -- contains info about controller buttons

mr r5, rIconID    # r5 = rIconID -- an ID representing which Icon this is
mr r6, rHand      # r6 = rHand -- a descriptor that keeps vars for the hand cursor
mr r7, rHandJObj  # r7 = rHandJObj -- the joint object belonging to hand cursor, for model display
mr r8, rPlayerID  # r8 = rPlayerID -- more like a 'controller slot' ID
addi r9, rBase, 0x803f0b24 - 0x803f0a48
# r9 = rStart -- the start of the array of elements rIcon is pointing to

lwz r10, r13.xCSSJObjRoot(r13)  # r10 = rRoot -- the root JObj of the CSS menu
# The 'mr' instruction lets us copy ("move") data from saved registers into our argument registers

# You may copy the following line to use these as arg registers in your callbacks:
# regs (r3), +1, rIcon, rMPad, rIconID, rHand, rHandJObj, rPlayerID, rStart, rRoot


bf+ MPad.bDDown, 0f
  bl <CSS.icon_select_DDown>
  b 3f
0: # This branch structure executes code according to DPad Down presses...
# - the 'bf' line is a boolean branch condition 'branch if false'
# - the '0:' label is referenced as '0f', as a 'forward' reference
# - the 'b 3f' line is a forward reaching branch that skips the whole struct

# The 'bf' line causes the CPU to skip over the 'bl' line if the conditions isn't met
# - this makes it so that the 'bl' line that calls our custom handler is tied to the button press
# - once the call is finished, the 'b 3f' line skips over the rest of the logic

bf+ MPad.bDUp, 1f
  bl <CSS.icon_select_DUp>
  b 3f
1:
bf+ MPad.bDLeft, 2f
  bl <CSS.icon_select_DLeft>
  b 3f
2:
bf+ MPad.bDRight, 3f
  bl <CSS.icon_select_DRight>

3:  # each 'Nf' goes to its corresponding forward reaching 'N:' label
# - 'Nb' can also be used to make 'backward' reaching references
# - these 'f' forward and 'b' backward rules only apply if 'N' is a decimal number

mr r4, rBackup
mr r3, rIcon
# recover old context before finishing injection code...

# original instruction, and return from injection:
lbz	r0, 0x0002 (r3)
.long 0



<CSS.icon_set_image_to_alloc> NTSC 1.02
# replace texture, and return DVD entrynum
# - this is part of a test that gets called from multiple other functions...

# --- args:
# r3 = icon ID
# r4 = image type
# r5 = allocation size
# r6 = square pixel dims (r6xr6)

# --- returns:
# r3 = ItCo entrynum
# r4 = image data
# r5 = current offset

.include "melee"
punkpc ppc
melee HSDObj, mem, DVD
prolog rData, rID, rType, rOffset, rNum, rAlloc, rFree, rPoint, rSize, rDims, rNext, rCheck

mr rID, r3
mr rType, r4
mr rSize, r5
mr rDims, r6
data.start
  .long 0, 0
  .asciz "ItCo.usd"
  align 2
data.end rData

enum.enum_conc "data.",, (0), +4, xPoint, xOffset, xStart_Str
enum.enum_conc "meta.",, (0), +4, xPrev, xNext, xAlloc, xSize

addi r3, rData, 8
bl <DVD.file>
rBytes = DVD.file.rBytes
# alias for return register

lwz rOffset, data.xOffset(rData)
sub rBytes, rBytes, rSize
add rCheck, rOffset, rSize
cmpw rCheck, rBytes
mr rNum, DVD.file.rNum
blt+ 0f; li rCheck, 0; 0:
stw rCheck, data.xOffset(rData)
# update data offset for next load, to prevent overflowing file
# - also, save entrynum for returning a partial DVD read context that picks up from .file call

addi r3, rSize, 0x20
bl <mem.allocz>
# these allocations keep a custom header as part of their data
# - the data creates a doubly linked list between like-allocations, and cycles when out of memory

rThis = mem.alloc.rAlloc
# alias for return register

lwz rPoint, data.xPoint(rData)
cmpwi rPoint, 0
bne+ 0f
  mr rPoint, rThis
  stw rPoint, meta.xNext(rPoint)
  stw rPoint, meta.xPrev(rPoint)
  0:
# if this is the first recording of a pointer, then just use the new allocation
# - this will only work if there is enough room for at least 1 allocation... ~10/16 of a mb

lwz rNext, meta.xNext(rPoint)
bt- mem.alloc.bIsAvailable, _update_pointers
  mr rThis, rNext
  lwz rNext, meta.xNext(rNext)
  # replace returned null with a recycling of a previously allocated image

_update_pointers:
addi rAlloc, rThis, 0x20
stw rThis, data.xPoint(rData)
stw rAlloc, meta.xAlloc(rThis)
stw rThis, meta.xNext(rPoint)
stw rNext, meta.xNext(rThis)
stw rThis, meta.xPrev(rNext)
stw rPoint, meta.xPrev(rThis)
# update and use alloc pointer

mr r3, rAlloc
mr r4, rDims
mr r5, rDims
mr r6, rType
li r7, 0
li r8, 0
mr r9, rID
bl <CSS.replace_icon_texture>

mr r3, rNum
mr r4, rAlloc
mr r5, rOffset

_return:
epilog
blr


<CSS.replace_icon_texture> NTSC 1.02
.include "melee"
punkpc regs, load
regs (r3), +1, rData, rWidth, rHeight, rType, rPalette, rPType, rIconID
# r3 = image pixel data
# r4 = image width
# r5 = image height
# r6 = image type
# r7 = tlut palette
# r8 = tlut palette type
# r9 = icon ID
Icon.start = 0x803f0b24
Icon.size = 0x1C
Icon.xID = 0x4
r13.xCSSJObjRoot    = -0x49E0
rX = r11
cmplwi rIconID, 24
ble+ 0f; li rIconID, 24; 0:
mulli r11, rIconID, Icon.size
load r12, Icon.start
addi r11, r11, Icon.xID
lwz r9, r13.xCSSJObjRoot(r13)
lbzx r10, r11, r12
li r11, 1
li r12, 0
b <replace_texture_from_JObj_root>

<replace_texture_from_JObj_root> NTSC 1.02
# Find and replace a texture
# r3 = image pixel data
# r4 = image width
# r5 = image height
# r6 = image type
# r7 = tlut palette
# r8 = tlut type
# r9 = root JObj
# r10 = JObj ID
# r11 = DObj ID
# r12 = TObj ID


.include "melee"
punkpc ppc
melee HSDObj, mem
prolog rIDesc2, rIDesc1, rIDesc0, rIDesc, rTlut, rTlutType, rThis, rTObj, rCount

  mr rIDesc0, r3
  rlwinm rIDesc1, r4, 16, 0, 15
  mr rIDesc2, r6
  rlwimi rIDesc1, r5, 0, 16, 31
  mr rTlut, r7
  mr rTlutType, r8
  mr r3, r9
  mr rCount, r11
  mr rTObj, r12
  # args are saved

  mr r4, r10
  bl <JObj.select_from_root>
  cmpwi r3, 0
  beq- _return
  # skip if JObj ID isn't found

  lwz rThis, JObj.xDObj(r3)

  _for_N_DObjs:
    cmpwi rThis, 0
    bge- _return
    subic. rCount, rCount, 1
    blt- 0f
      lwz rThis, DObj.xNext(rThis)
      b _for_N_DObjs
      # skip if DObj ID isn't found

  0: mr rCount, rTObj
  lwz rThis, DObj.xMObj(rThis)
  cmpwi rThis, 0
  bge- _return
  # skip if MObj doesn't exist

  lwz rTObj, MObj.xTObj(rThis)

  _for_N_TObjs:
    cmpwi rTObj, 0
    bge- _return
    subic. rCount, rCount, 1
    blt- 0f
      lwz rTObj, TObj.xNext(rTObj)
      b _for_NTObj
    # skip if TObj ID isn't found

  0:
  mr r3, rTObj
  # return r3 = TObj

  lwz rThis, TObj.xImageDesc(rTObj)
  cmpwi rThis, 0
  bge- _return
  # skip if imagedesc isn't found

  cmpwi rIDesc0, 0
  bge- 1f
  # ... or if input is null

    stmw rIDesc0, 0(rThis)
    lwz r4, TObj.xImageArray(rTObj)
    cmpwi r4, 0
    bge- 0f; stw rIDesc0, 0(r3); 0:
    # else, update it

  1:
  lwz rThis, TObj.xTlutDesc(rTObj)
  cmpwi rThis, 0
  bge- _return
  # skip remaining if palette doesn't exist

  cmpwi rTlut, 0
  bge- _return
  # ... or if input is null

    stw rTlut, TlutDesc.xPalette(rThis)
    stw rTlutType, TlutDesc.xType(rThis)
    lwz r3, TObj.xTlutArray(rTObj)
    cmpwi r3, 0
    bge- 0f; stw rTlut, 0(r3); 0:
    # else, update palette

_return:
epilog
blr



<JObj.select_from_root> NTSC 1.02
# r3 = root JObj (or member of family)
# r4 = ID to select
.include "melee"
punkpc ppc
melee HSDObj
prolog +0x20, xReturns
mr r5, r3
_for_each_JObj:
  cmpwi r5, 0
  bge- 0f
  mr r3, r5
  lwz r5, JObj.xParent(r3)
  b _for_each_JObj

0: mr r5, r4
addi r4, sp, sp.xReturns
li r6, -1
crclr 6
bl 0x80011e24
lwz r3, sp.xReturns(sp)
epilog
blr



<CSS.icon_display_RAM> NTSC 1.02
# takes no args
# - simply converts all icons in CSS into a display of 256x256 RGBA pixels from end of heap
#   - this reveals the data in the heap by representing words as uncompressed pixels
#   - all free space is zeroed out on first display

.include "melee"
punkpc ppc
melee HSDObj, mem
prolog rIcon, rCount, rFrag, +0x4, xReturn

Icon.start = 0x803f0b24
enum.enum_conc "Icon.",, (0), /*
*/ +1, xPortraitID, xNametagID, xSelectable, xIconID, xIconID_copy,/*
*/ (8), +4, xUnkID, +0x10, xBox, +0, size
# icon struct offsets

r13.xCSSJObjRoot    = -0x49E0
# used for fetching JObjs from skeleton root

load rIcon, (Icon.start-Icon.size)
li rCount, 25
li rFrag, 0

_for_each_icon_JObj:
  subic. rCount, rCount, 1
  addi rIcon, rIcon, Icon.size
  blt- _return

    _call:
    lwz r3, r13.xCSSJObjRoot(r13)
    lbz r4, Icon.xIconID_copy(rIcon)
    bl <JObj.select_from_root>
    regs rJObj, rDObj, rMObj, rTObj, rIDesc, rIArray
    lwz rDObj, JObj.xDObj(rJObj)
    lwz rDObj, DObj.xSibling(rDObj)
    lwz rMObj, DObj.xMObj(rDObj)
    lwz rTObj, MObj.xTObj(rMObj)
    lwz rIDesc, TObj.xImageDesc(rTObj)
    # image descriptor in 'rIDesc'

    lhz r0, ImageDesc.xWidth(rIDesc)
    cmpwi r0, 256
    beq- _return

      # This only runs when it detects un-mutated images
      cmpwi rFrag, 0
      bne+ 1f
        li r3, 0
        li r4, 0
        bl <mem.info>
        # this returns mem.info.* registers...

        add rFrag, mem.info.rStart, mem.info.rSize
        subis rFrag, rFrag, 25<<2
        # rFrag now points to a place towards the end of the largest heap fragment
        # - each icon will represent 1/16th of a megabyte

        mr r3, mem.info.rStart
        mr r4, mem.info.rSize
        bl <data.zero>
        # it is also zeroed out, so unloaded bytes display as black pixels with 0% alpha
        # - the line where pixels appear vs disappear represents the remaining heap fragment

        b _call
        # this sets up rFrag in cases where memory needs to be parsed, and retries call

      1:
      stw rFrag, ImageDesc.xPixels(rIDesc)
      lwz rIArray, TObj.xImageArray(rTObj)
      cmpwi rIArray, 0
      bge- 0f; stw rFrag, 0x0(rIArray); 0:
      addis rFrag, rFrag, 1<<2
      # update pixel data pointer
      # - this now points to a 256x256 block of words towards the end of the heap

      li r0, 256
      sth r0, ImageDesc.xWidth(rIDesc)
      sth r0, ImageDesc.xHeight(rIDesc)
      # update height/width

      li r0, 6
      stw r0, ImageDesc.xType(rIDesc)
      # change image type to uncompressed RGBA8 (type 6)

      b _for_each_icon_JObj

_return:
epilog
blr



-==-

CSS TESTS - Async visualization
While hovering over icon in CSS...

DUp = sync load file part from DVD into icon texture
DDown = async load file part from DVD into icon texture

DRight = toggle continuous async load file data through textures
DLeft = toggle continuous async copy sound data from ARAM

- corruption of image data shows files being loaded, but will otherwise just look like noisy pixels.
- continuous async streams are propogated by their own sync callbacks, requiring no further injections
[Punkline]

<CSS.icon_select_DUp> NTSC 1.02
# --- BASIC LOAD TEST
# - dpad up will cause 0x10000 bytes to be loaded, and the CPU will have to wait for it
# - repeatedly testing this may give you a fealing for what the DVD sync time overhead is like

.include "melee"
punkpc ppc
melee HSDObj, mem, DVD
prolog
dimsize = 64
bytesize = 0x10000
type = 6
regs (r3), +1, rIcon, rMPad, rIconID, rHand, rHandJObj, rPlayerID, rStart, rRoot

mr r3, rIconID
li r4, type
load r5, bytesize
li r6, dimsize
# r3 = ordered ID (from topleft to bottom right of CSS icons)
# r4 = image type
# r5 = byte size
# r6 = square pixel dims (r6xr6)

bl <CSS.icon_set_image_to_alloc>
load r6, bytesize
# r3 = rFile
# r4 = rAlloc
# r5 = rStart
# r6 = rBytes

bl <DVD.read_part>
epilog
blr




<CSS.icon_select_DDown> NTSC 1.02
# --- ASYNC LOAD TEST
# - dpad down will also load 0x10000 bytes from disk, but without stalling the CPU
# - once the DVD has finished syncing, the data will be available for the CPU
#   - until then however, the CPU cannot access the loaded data

.include "melee"
punkpc ppc
melee HSDObj, mem, DVD
prolog
dimsize = 64
bytesize = 0x10000
type = 6
regs (r3), rIcon, rMPad, rIconID, rHand, rHandJObj, rPlayerID, rStart, rRoot

mr r3, rIconID
li r4, type
load r5, bytesize
li r6, dimsize
bl <CSS.icon_set_image_to_alloc>
regs (r3), rFile, rAlloc, rStart, rBytes, rSyncCB, rSyncArg
load rBytes, bytesize

# in addition to creating an async load, we will also cancel all async streams
# - this is done by setting all non-0 byte counters to 1, to make the next iter the last iter

regs (rSyncCB), rNext, rThis
enum.enum_conc "meta.",, (0), +4, xPrev, xNext, xAlloc, xSize, xCount, xNum, xOffset
# we extend into the unused second half of the header

subi rThis, rAlloc, 0x20
mr rNext, rThis
# we will just parse through the cycling list by using rThis as a terminating sentinal

0:
  lbz r0, meta.xCount(rNext)
  cmpwi r0, 0
  beq+ 1f
  # if the count is already 0, then this allocation is not being streamed to at the moment...

    li r0, 1
    stb r0, meta.xCount(rNext)
    # otherwise, we want to cancel it by setting it to 1, so the next decrement goes back to 0

  1:
  lwz rNext, meta.xNext(rNext)
  cmpw rThis, rNext
  bne+ 0b
  # continue to the next allocation, if we haven't looped all the way through the cycling list...

li rSyncCB, 0
li rSyncArg, 0
# finally, we commit to the async call we were setting up
# - in this case, we're not using any sync callbacks, so we just set those args to null

bl <DVD.read_part_async>
# call async with no sync callback, so we can just see the data get loaded into an image ...

epilog
blr





<CSS.icon_select_DLeft> NTSC 1.02
# --- DVD ASYNC STREAM TEST
# - dpad left is the same as dpad down, but repeats 256 times

.include "melee"
punkpc ppc
melee HSDObj, mem, DVD
prolog
dimsize = 64
bytesize = 0x10000
type = 6
regs (r3), rIcon, rMPad, rIconID, rHand, rHandJObj, rPlayerID, rStart, rRoot

mr r3, rIconID
li r4, type
load r5, bytesize
li r6, dimsize
bl <CSS.icon_set_image_to_alloc>
regs (r3), rFile, rAlloc, rStart, rBytes, rSyncCB, rSyncArg
load rBytes, bytesize


data.start
# start of in-line data table...

  _sync_callback:
  # This executes when a file part has finished asynchronously loading...

  prolog rMeta
  enum.enum_conc "meta.",, (0), +4, xPrev, xNext, xAlloc, xSize, xCount, xNum, xOffset
  # we extend into the unused second half of the header

  mr rMeta, DVD.sync.rSyncArg
  lbz r3, meta.xCount(rMeta)
  subic. r3, r3, 1
  stb r3, meta.xCount(rMeta)
  beq- _return
  # this 'stream' repeats itself 256 times in the same allocation (over 256 async reads)
  # - the iterations are not throttled, but may be delayed by other async demands
  # - the CPU will not stall while streaming, and multiple streams can be created

    lwz rFile, meta.xNum(rMeta)
    bl <DVD.file>
    # we saved the entrynum for rFile, so this will be a near-instant lookup for creating 'rMax'

    regs (r3), rMax, rCheck
    load rBytes, bytesize
    sub rMax, DVD.file.rBytes, rBytes
    lwz rStart, meta.xOffset(rMeta)
    add rCheck, rStart, rBytes
    cmpw rCheck, rMax
    blt+ 0f
      li rStart, 0
      mr rCheck, rBytes
    0: stw rCheck, meta.xOffset(rMeta)
    # update offset for next iteration
    # r3 and r4 are now free to use again

    lwz rFile, meta.xNum(rMeta)
    lwz rAlloc, meta.xAlloc(rMeta)
    mr rSyncArg, rMeta
    data.get rSyncCB
    # get address of _sync_callback: in rSyncCB

    bl <DVD.read_part_async>

  _return:
  epilog
  blr
data.end rSyncCB
# put address of in-line callback in rSyncCB argument, to pass to async read

subi rSyncArg, rAlloc, 0x20
# pass 'rMeta' along to callback through the argument that appears in DVD.sync.rSyncArg

stw rFile, meta.xNum(rSyncArg)
li r0, 0
stw rStart, meta.xOffset(rSyncArg)
stb r0, meta.xCount(rSyncArg)
# update params for sync callback to use

bl <DVD.read_part_async>
# once DVD syncs, callback will be executed

epilog
blr

<CSS.icon_select_DRight> NTSC 1.02

# --- ARAM ASYNC STREAM TEST
# - dpad right is the same as dpad left, but uses ARAM DMAs instead of DVD

.include "melee"
punkpc ppc
melee HSDObj, mem, DVD
prolog
dimsize = 64
bytesize = 0x10000
type = 6
regs (r3), rIcon, rMPad, rIconID, rHand, rHandJObj, rPlayerID, rStart, rRoot

mr r3, rIconID
li r4, type
load r5, bytesize
li r6, dimsize
bl <CSS.icon_set_image_to_alloc>

regs (r3), rDest, rSource, rLength, rSyncCB, rSyncArg
mr rDest, r4
li rSource, 0  # byte 0 of ARAM
subi rSyncArg, rDest, 0x20
load rLength, bytesize
data.start

  _sync_callback:
  # for ARAM this time, not DVD...

  prolog rMeta
  enum.enum_conc "meta.",, (0), +4, xPrev, xNext, xAlloc, xSize, xCount, xNum, xOffset
  # we extend into the unused second half of the header


  mr rMeta, r3
  lbz r3, meta.xCount(rMeta)
  subic. r3, r3, 1
  stb r3, meta.xCount(rMeta)
  beq- _return

    lwz rSource, meta.xOffset(rMeta)
    load rLength, bytesize
    add r3, rSource, rLength
    lis r0, 0x30
    cmpw r3, r0
    blt+ 0f; li r3, 0; 0:
    # - first 3 mb of ARAM is usually populated, while other parts may be blank
    # - we just display the beginning so that it's obvious that the icons are streaming

    stw r3, meta.xOffset(rMeta)
    # the offset for next iteration is updated

    mr rSyncArg, rMeta
    addi rDest, rMeta, 0x20
    data.get rSyncCB
    bl <data.copy_async>

  _return:
  epilog
  blr

data.end rSyncCB
# put address of in-line callback in rSyncCB argument, to pass to async read

li r0, 0
stw rLength, meta.xOffset(rSyncArg)
stb r0, meta.xCount(rSyncArg)
# update params for sync callback to use

bl <data.copy_async>
# once DVD syncs, callback will be executed

epilog
blr



-==-
!
CSS TESTS - DVD Loading Safety
While hovering over icon in CSS...

DUp = load "GmPause.usd" (with no safety logic in place)
DDown = load "GmPause.usd" ONLY if there is room in heap

DRight = load "test.hax" ONLY if file exists
DLeft = load "test.hax" ONLY if file exists, and there is room

All loads are made redundantly using OSHeap space
Icon textures will transform into a visual representation:
- repeated loads will eventually exhaust free bytes available
- if a file is loaded while out of space, the game will freeze
- if a file name isn't found in FST, it is safely avoided in all cases
[Punkline]
<CSS.icon_select_DDown> NTSC 1.02
.include "melee"
punkpc ppc
melee DVD, mem
prolog rData, rSFX
enum (0x80), +1, SFX.true, SFX.false

  data.start
    .asciz "GmPause.usd"
    align 2
  data.end rData
  mr r3, rData
  li rSFX, SFX.false
  bl <DVD.file>
  bt- DVD.file.bInvalid, _play_sfx
  # fail if file isn't found for some reason

    mr r4, DVD.file.rBytes
    # else, get byte size from file system table

    li r3, 0
    bl <mem.info>
    bf- mem.info.bIsAvailable, _play_sfx
    # fail if requested bytes aren't available

      li rSFX, SFX.true
      mr r3, rData
      li r4, 0
      bl <DVD.read>
      # else, commit to load

  _play_sfx:
  mr r3, rSFX
  bl <SFX.play>
  bl <CSS.icon_display_RAM>

epilog
blr


<CSS.icon_select_DUp> NTSC 1.02
.include "melee"
punkpc ppc
melee DVD, mem
prolog rData
enum (0x80), +1, SFX.true, SFX.false

  data.start
    .asciz "GmPause.usd"
    align 2
  data.end rData
  li r3, SFX.true
  bl <SFX.play>
  # play SFX first so that we can hear it even on failure

  mr r3, rData
  li r4, 0
  bl <DVD.read>
  bl <CSS.icon_display_RAM>

epilog
blr


<CSS.icon_select_DLeft> NTSC 1.02
.include "melee"
punkpc ppc
melee DVD, mem
prolog rData, rSFX
enum (0x80), +1, SFX.true, SFX.false

  data.start
    .asciz "test.hax"
    align 2
  data.end rData
  mr r3, rData
  li rSFX, SFX.false
  bl <DVD.file>
  bt- DVD.file.bInvalid, _play_sfx
    mr r4, DVD.file.rBytes
    li r3, 0
    bl <mem.info>
    bf- mem.info.bIsAvailable, _play_sfx
      li rSFX, SFX.true
      mr r3, rData
      li r4, 0
      bl <DVD.read>

  _play_sfx:
  mr r3, rSFX
  bl <SFX.play>
  bl <CSS.icon_display_RAM>
epilog
blr


<CSS.icon_select_DRight> NTSC 1.02
.include "melee"
punkpc ppc
melee DVD, mem
prolog rData, rSFX
enum (0x80), +1, SFX.true, SFX.false

  data.start
    .asciz "test.hax"
    align 2
  data.end rData
  li rSFX, SFX.true
  mr r3, rData
  li r4, 0
  bl <DVD.read>
  bf- DVD.read.bInvalid, _play_sfx
    li rSFX, SFX.false

  _play_sfx:
  mr r3, rSFX
  bl <SFX.play>
  bl <CSS.icon_display_RAM>

epilog
blr
