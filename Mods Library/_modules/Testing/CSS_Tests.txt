-==-

CSS - Icon selection DPad events
[Punkline]
Revision ---- DOL Offset ---- Hex to Replace ---------- ASM Code -
NTSC 1.02 --- 0x80260c14 ---- 88030002 -> Branch
.include "melee";
punkpc ppc          # powerpc utilities
melee MPad, HSDObj   # controller pad symbols and HSD Symbols


# the 'regs' macro helps us name registers counting up +1 or down +1 from a starting register (rN)

regs -1, /*
*/ (r31), rHand, rBase, rHandJObj, rInput, /*
*/ (r24), rIcon, rBackup, /*
*/ (r20), rIconID, rPlayerID

# -- these registers help us understand the context of this injection point
# 803f0a48 = base address in rBase


r13.xCSSJObjRoot    = -0x49E0
# r13 offset of root JObj for CSS icons/portraits


# code start:

mr rIcon, r3
mr rBackup, r4
# back these up for now, so that we don't disrupt the normal game program
# - the assigned registers in the above 'regs' call puts these in a safe place

load r4, MPad.addr
lwz r0, MPad.xOnPress(r4)
mtcrf MPad.crf.mDPad, r0
# We can check DPad button presses from the Master Pad .xOnPress bool field
# - loading it into cr directly lets us use the bools without having to compare anything

# We can use these bools to 'call' custom code based on whether or not the bits are True
# Once the custom code is finished, it will 'return' back to the place it was called from

# Registers r3 ... r12 may be used to safely 'pass' information to our called code

# Currently, we have the following set up:
# r3 = rIcon -- a descriptor that keeps vars for the icon currently being hovered over by cursor
# r4 = rMPad -- the master pad struct for player 1 -- contains information about controller buttons

mr r5, rIconID    # r5 = rIconID -- an ID representing which Icon this is
mr r6, rHand      # r6 = rHand -- a descriptor that keeps vars for the hand cursor
mr r7, rHandJObj  # r7 = rHandJObj -- the joint object belonging to hand cursor, for model display
mr r8, rPlayerID  # r8 = rPlayerID --
# The 'mr' instruction lets us copy ("move") data from saved registers into our argument registers

bf+ MPad.bDDown, 0f
  bl <CSS.icon_select_DDown>
  b 3f
0: # This branch structure executes code according to DPad Down presses...
# - the 'bf' line is a boolean branch condition 'branch if false'
# - the '0:' label is referenced as '0f', as a 'forward' reference
# - the 'b 3f' line is a forward reaching branch that skips the whole struct

# The 'bf' line causes the CPU to skip over the 'bl' line if the conditions isn't met
# - this makes it so that the 'bl' line that calls our custom handler is tied to the button press
# - once the call is finished, the 'b 3f' line skips over the rest of the logic

bf+ MPad.bDUp, 1f
  bl <CSS.icon_select_DUp>
  b 3f
1:
bf+ MPad.bDLeft, 2f
  bl <CSS.icon_select_DLeft>
  b 3f
2:
bf+ MPad.bDRight, 3f
  bl <CSS.icon_select_DRight>

3:  # each 'Nf' goes to its corresponding forward reaching 'N:' label
# - 'Nb' can also be used to make 'backward' reaching references
#   - because of this, only 2 instances of each number are kept in assembler memory at one time
#   - these can be thought of as anonymous, local, 'temporary' labels


mr r4, rBackup
mr r3, rIcon
# recover old context before finishing injection code...

# original instruction, and return from injection:
lbz	r0, 0x0002 (r3)
.long 0


-==-

CSS TESTS - Async visualization
While hovering over icon in CSS...

DUp = sync load file part from DVD into icon texture
DDown = async load file part from DVD into icon texture

DRight = toggle continuous async load file data through textures
DLeft = toggle continuous async copy sound data from ARAM

- corruption of image data shows files being loaded, but will otherwise just look like noisy pixels.
- continuous async streams are propogated by their own sync callbacks, requiring no further injections
[Punkline]

<CSS.icon_select_DUp> NTSC 1.02


<CSS.icon_select_DDown> NTSC 1.02


-==-

CSS TESTS - DVD Loading Safety
While hovering over icon in CSS...

DUp = load "GmPause.usd"
DDown = load "GmPause.usd" ONLY if there is room in heap

DRight = load "test.hax"
DLeft = load "test.hax" ONLY if file exists, and there is room

All loads are made redundantly using OSHeap space
- repeated loads will eventually exhaust free bytes available
- if a file is loaded while out of space, the game will freeze
- if a file name isn't found in FST, it is safely avoided in all cases
[Punkline]


<CSS.icon_select_DDown> NTSC 1.02
.include "melee"
punkpc ppc
melee DVD, mem
prolog rData, rSFX
enum (0x80), +1, SFX.true, SFX.false

  data.start
    .asciz "GmPause.usd"
    align 2
  data.end rData
  mr r3, rData
  li rSFX, SFX.false
  bl <DVD.file>
  bt- DVD.file.bInvalid, _play_sfx
  # fail if file isn't found for some reason

    mr r4, DVD.file.rBytes
    # else, get byte size from file system table

    li r3, 0
    bl <mem.info>
    bf- mem.info.bIsAvailable, _play_sfx
    # fail if requested bytes aren't available

      li rSFX, SFX.true
      mr r3, rData
      li r4, 0
      bl <DVD.read>
      # else, commit to load

  _play_sfx:
  mr r3, rSFX
  bl <SFX.play>

epilog
blr


<CSS.icon_select_DUp> NTSC 1.02
.include "melee"
punkpc ppc
melee DVD, mem
prolog rData
enum (0x80), +1, SFX.true, SFX.false

  data.start
    .asciz "GmPause.usd"
    align 2
  data.end rData
  li r3, SFX.true
  bl <SFX.play>
  # play SFX first so that we can hear it even on failure

  mr r3, rData
  li r4, 0
  bl <DVD.read>

epilog
blr


<CSS.icon_select_DLeft> NTSC 1.02
.include "melee"
punkpc ppc
melee DVD, mem
prolog rData, rSFX
enum (0x80), +1, SFX.true, SFX.false

  data.start
    .asciz "test.hax"
    align 2
  data.end rData
  mr r3, rData
  li rSFX, SFX.false
  bl <DVD.file>
  bt- DVD.file.bInvalid, _play_sfx
    mr r4, DVD.file.rBytes
    li r3, 0
    bl <mem.info>
    bf- mem.info.bIsAvailable, _play_sfx
      li rSFX, SFX.true
      mr r3, rData
      li r4, 0
      bl <DVD.read>

  _play_sfx:
  mr r3, rSFX
  bl <SFX.play>
epilog
blr


<CSS.icon_select_DRight> NTSC 1.02
.include "melee"
punkpc ppc
melee DVD, mem
prolog rData, rSFX
enum (0x80), +1, SFX.true, SFX.false

  data.start
    .asciz "test.hax"
    align 2
  data.end rData
  li rSFX, SFX.true
  mr r3, rData
  li r4, 0
  bl <DVD.read>
  bf- DVD.read.bInvalid, _play_sfx
    li rSFX, SFX.false

  _play_sfx:
  mr r3, rSFX
  bl <SFX.play>

epilog
blr
