-==-

CSS - Icon selection DPad events
[Punkline]
Revision ---- DOL Offset ---- Hex to Replace ---------- ASM Code -
NTSC 1.02 --- 0x80260c14 ---- 88030002 -> Branch
.include "melee";
punkpc ppc          # powerpc utilities
melee MPad, HSDObj   # controller pad symbols and HSD Symbols


# the 'regs' macro helps us name registers counting up +1 or down +1 from a starting register (rN)

regs -1, /*
*/ (r31), rHand, rStart, rHandJObj, rInput, /*
*/ (r24), rIcon, rBackup, /*
*/ (r20), rIconID, rPlayerID

# -- these registers help us understand the context of this injection point
# 803f0a48 = base address in rStart


r13.xCSSJObjRoot    = -0x49E0
# r13 offset of root JObj for CSS icons/portraits


# code start:

mr rIcon, r3
mr rBackup, r4
# back these up for now, so that we don't disrupt the normal game program
# - the assigned registers in the above 'regs' call puts these in a safe place

load r4, MPad.addr
mulli r0, rPlayerID, MPad.size
add r4, r4, r0
lwz r0, MPad.xOnPress(r4)
mtcrf MPad.crf.mDPad, r0
# We can check DPad button presses from the Master Pad .xOnPress bool field
# - loading it into cr directly lets us use the bools without having to compare anything

# We can use these bools to 'call' custom code based on whether or not the bits are True
# Once the custom code is finished, it will 'return' back to the place it was called from

# Registers r3 ... r12 may be used to safely 'pass' information to our called code

# Currently, we have the following set up:
# r3 = rIcon -- a descriptor that keeps vars for the icon currently being hovered over by cursor
# r4 = rMPad -- the master pad struct for this player -- contains info about controller buttons

mr r5, rIconID    # r5 = rIconID -- an ID representing which Icon this is
mr r6, rHand      # r6 = rHand -- a descriptor that keeps vars for the hand cursor
mr r7, rHandJObj  # r7 = rHandJObj -- the joint object belonging to hand cursor, for model display
mr r8, rPlayerID  # r8 = rPlayerID -- more like a 'controller slot' ID
mr r9, rStart      # r9 = rStart -- the start of the array of elements rIcon is pointing to
lwz r10, r13.xCSSJObjRoot(r13)  # r10 = rRoot -- the root JObj of the CSS menu
# The 'mr' instruction lets us copy ("move") data from saved registers into our argument registers

bf+ MPad.bDDown, 0f
  bl <CSS.icon_select_DDown>
  b 3f
0: # This branch structure executes code according to DPad Down presses...
# - the 'bf' line is a boolean branch condition 'branch if false'
# - the '0:' label is referenced as '0f', as a 'forward' reference
# - the 'b 3f' line is a forward reaching branch that skips the whole struct

# The 'bf' line causes the CPU to skip over the 'bl' line if the conditions isn't met
# - this makes it so that the 'bl' line that calls our custom handler is tied to the button press
# - once the call is finished, the 'b 3f' line skips over the rest of the logic

bf+ MPad.bDUp, 1f
  bl <CSS.icon_select_DUp>
  b 3f
1:
bf+ MPad.bDLeft, 2f
  bl <CSS.icon_select_DLeft>
  b 3f
2:
bf+ MPad.bDRight, 3f
  bl <CSS.icon_select_DRight>

3:  # each 'Nf' goes to its corresponding forward reaching 'N:' label
# - 'Nb' can also be used to make 'backward' reaching references

mr r4, rBackup
mr r3, rIcon
# recover old context before finishing injection code...

# original instruction, and return from injection:
lbz	r0, 0x0002 (r3)
.long 0


-==-
!
CSS TESTS - Async visualization
While hovering over icon in CSS...

DUp = sync load file part from DVD into icon texture
DDown = async load file part from DVD into icon texture

DRight = toggle continuous async load file data through textures
DLeft = toggle continuous async copy sound data from ARAM

- corruption of image data shows files being loaded, but will otherwise just look like noisy pixels.
- continuous async streams are propogated by their own sync callbacks, requiring no further injections
[Punkline]

<CSS.icon_select_DUp> NTSC 1.02

<CSS.icon_select_DDown> NTSC 1.02


-==-

CSS TESTS - DVD Loading Safety
While hovering over icon in CSS...

DUp = load "GmPause.usd"
DDown = load "GmPause.usd" ONLY if there is room in heap

DRight = load "test.hax"
DLeft = load "test.hax" ONLY if file exists, and there is room

All loads are made redundantly using OSHeap space
- repeated loads will eventually exhaust free bytes available
- if a file is loaded while out of space, the game will freeze
- if a file name isn't found in FST, it is safely avoided in all cases
[Punkline]
<CSS.icon_display_RAM> NTSC 1.02
# takes no args
# - simply converts all icons in CSS into a display of 256x256 RGBA pixels from end of heap
#   - this reveals the data in the heap by representing words as uncompressed pixels
#   - all free space is zeroed out on first display

.include "melee"
punkpc ppc
melee HSDObj, mem
prolog rIcon, rCount, rFrag, +0x4, xReturn

Icon.base = 0x803f0b24
enum.enum_conc "Icon.",, (0), /*
*/ +1, xPortraitID, xNametagID, xSelectable, xIconID, xIconID_copy,/*
*/ (8), +4, xUnkID, +0x10, xBox, +0, size
# icon struct offsets

r13.xCSSJObjRoot    = -0x49E0
# used for fetching JObjs from skeleton root

load rIcon, (Icon.base-Icon.size)
li rCount, 25
li rFrag, 0

_for_each_icon_JObj:
  subic. rCount, rCount, 1
  addi rIcon, rIcon, Icon.size
  blt- _return

    _call:
    lwz r3, r13.xCSSJObjRoot(r13)
    addi r4, sp, sp.xReturn
    lbz r5, Icon.xIconID_copy(rIcon)
    li r6, -1
    bl 0x80011e24
    regs rJObj, rDObj, rMObj, rTObj, rIDesc, rIArray
    lwz rJObj, sp.xReturn(sp)
    lwz rDObj, JObj.xDObj(rJObj)
    lwz rDObj, DObj.xSibling(rDObj)
    lwz rMObj, DObj.xMObj(rDObj)
    lwz rTObj, MObj.xTObj(rMObj)
    lwz rIDesc, TObj.xImageDesc(rTObj)
    # image descriptor in 'rIDesc'

    lhz r0, ImageDesc.xWidth(rIDesc)
    cmpwi r0, 256
    beq- _return

      # This only runs when it detects un-mutated images
      cmpwi rFrag, 0
      bne+ 1f
        li r3, 0
        li r4, 0
        bl <mem.info>
        # this returns mem.info.* registers...

        add rFrag, mem.info.rStart, mem.info.rSize
        subis rFrag, rFrag, 25<<2
        # rFrag now points to a place towards the end of the largest heap fragment
        # - each icon will represent 1/16th of a megabyte

        mr r3, mem.info.rStart
        mr r4, mem.info.rSize
        bl <data.zero>
        # it is also zeroed out, so unloaded bytes display as black pixels with 0% alpha
        # - the line where pixels appear vs disappear represents the remaining heap fragment

        b _call
        # this sets up rFrag in cases where memory needs to be parsed, and retries call

      1:
      stw rFrag, ImageDesc.xPixels(rIDesc)
      lwz rIArray, TObj.xImageArray(rTObj)
      cmpwi rIArray, 0
      bge- 0f; stw rFrag, 0x0(rIArray); 0:
      addis rFrag, rFrag, 1<<2
      # update pixel data pointer
      # - this now points to a 256x256 block of words towards the end of the heap

      li r0, 256
      sth r0, ImageDesc.xWidth(rIDesc)
      sth r0, ImageDesc.xHeight(rIDesc)
      # update height/width

      li r0, 6
      stw r0, ImageDesc.xType(rIDesc)
      # change image type to uncompressed RGBA8 (type 6)

      b _for_each_icon_JObj

_return:
epilog
blr




<CSS.icon_select_DDown> NTSC 1.02
.include "melee"
punkpc ppc
melee DVD, mem
prolog rData, rSFX
enum (0x80), +1, SFX.true, SFX.false

  data.start
    .asciz "GmPause.usd"
    align 2
  data.end rData
  mr r3, rData
  li rSFX, SFX.false
  bl <DVD.file>
  bt- DVD.file.bInvalid, _play_sfx
  # fail if file isn't found for some reason

    mr r4, DVD.file.rBytes
    # else, get byte size from file system table

    li r3, 0
    bl <mem.info>
    bf- mem.info.bIsAvailable, _play_sfx
    # fail if requested bytes aren't available

      li rSFX, SFX.true
      mr r3, rData
      li r4, 0
      bl <DVD.read>
      # else, commit to load

  _play_sfx:
  mr r3, rSFX
  bl <SFX.play>
  bl <CSS.icon_display_RAM>

epilog
blr


<CSS.icon_select_DUp> NTSC 1.02
.include "melee"
punkpc ppc
melee DVD, mem
prolog rData
enum (0x80), +1, SFX.true, SFX.false

  data.start
    .asciz "GmPause.usd"
    align 2
  data.end rData
  li r3, SFX.true
  bl <SFX.play>
  # play SFX first so that we can hear it even on failure

  mr r3, rData
  li r4, 0
  bl <DVD.read>
  bl <CSS.icon_display_RAM>

epilog
blr


<CSS.icon_select_DLeft> NTSC 1.02
.include "melee"
punkpc ppc
melee DVD, mem
prolog rData, rSFX
enum (0x80), +1, SFX.true, SFX.false

  data.start
    .asciz "test.hax"
    align 2
  data.end rData
  mr r3, rData
  li rSFX, SFX.false
  bl <DVD.file>
  bt- DVD.file.bInvalid, _play_sfx
    mr r4, DVD.file.rBytes
    li r3, 0
    bl <mem.info>
    bf- mem.info.bIsAvailable, _play_sfx
      li rSFX, SFX.true
      mr r3, rData
      li r4, 0
      bl <DVD.read>

  _play_sfx:
  mr r3, rSFX
  bl <SFX.play>
  bl <CSS.icon_display_RAM>
epilog
blr


<CSS.icon_select_DRight> NTSC 1.02
.include "melee"
punkpc ppc
melee DVD, mem
prolog rData, rSFX
enum (0x80), +1, SFX.true, SFX.false

  data.start
    .asciz "test.hax"
    align 2
  data.end rData
  li rSFX, SFX.true
  mr r3, rData
  li r4, 0
  bl <DVD.read>
  bf- DVD.read.bInvalid, _play_sfx
    li rSFX, SFX.false

  _play_sfx:
  mr r3, rSFX
  bl <SFX.play>
  bl <CSS.icon_display_RAM>

epilog
blr
