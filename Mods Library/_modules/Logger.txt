-==-

Dolphin Logger Functions

log.print  # print ascii to Dolphin Log 'OSReport' output
args: rString, rArg1, rArg2, rArg3 ...
# - printed lines are formatted with the following escapes
#   - FPRS:  %f = float,  %e = exponent
#   - GPRS:  %s = str,  %x = hex,  %d, %i = signed decimal
#   - GPRS:  %u = unsigned decimal,  %\x23\ x = prefixed hex
#   - GPRS:  %\x23\ 04x = 4-digits of hex, including prefix
# - printed lines must be 1024 chars or less
# - printed lines will flood stdout and obfuscate error messages

log.nl  # Print a null message to give appearence of newline

log.timestamp  # returns details about current frame/time
returns: rScene, rRel, rBoot, rID, rTrans, rMajor, rMinor, rTBU, rTBL, fScene, fRel, fBoot

[Punkline]
# --- generic tools:

<log.print> NTSC 1.02
# This logs a formatted print message in the Dolphin logger, and can use floating point args
# - log messages will flood EXI buffer with ascii, obfuscating some error outputs in the game

# --- args:
# r3 = address of format string
# - string MUST begin with a space, and may include escapes for inserting formatted arguments
#   - FPR escapes:  %f = float,  %e = exponent
#   - GPR escapes:  %s = str,  %x = hex,  %d, %i = signed decimal,  %u = unsigned decimal
#   - %\x23\ x  -- this format makes hex with a prefix '0x'
#   -
# r4...r10 = GPR arguments
# f1...f8  = FPR arguments
# - these will be fed into the escapes found in the format string, as needed

crorc 6, 6, 6  # enables FPR args
b 0x80323eb4   # printf


<log.nl>
# Prints a null message to give the appearence of a newline without emitting one
mflr r0
stwu sp, -0x20(sp)
stw  r0,  0x20+4(sp)
li r0, 0
stw r0, 0x10(sp)
addi r3, sp, 0x10
bl <log.print>
lwz  r0,  0x20+4(sp)
addi sp, sp, 0x20
mtlr r0
blr



<log.timestamp> NTSC 1.02
# takes no args, and returns the following identifying timestamp data:
# --- Retrns:
# f1 = Scene frame
#    - integer index counter -- not a real timer
#      - index counts up once before the GProc, GXDraw steps in a scene frame execute
#      - updated as part of the HSD Performance stat routine implemented in the scene loop
# f2 = Relative frame
#    - using HSD Performance stat timestamps
#      - f2 is the real time relative to the start of the counted frame in f1
#      - very accurate -- should maintain precision of 20-nanosecond increments
# f3 = Boot frame
#    - using OS boot timestamp to create a sample runtime frame timestamp

# r3 = Scene frame
# r4 = Relative frame (in microframes)
#    + FFF00000 = full frames
#    + 000FFFFF = microframes
#    - microframes count in-between frames, relative to the performance monitor timestamps
#    - full frames will be <1 unless something is causing the scene frame ticks to stall:
#      - >1 when the GProc or GXDraw step of a scene takes too long
#      - >1 when the CPU is stalling while waiting for hardware to sync
# r5 = Boot frame

# r6 = compressed ID: [r7, r8, r9]
#    - r6 is convenient for implementing into timestamp messages if individual IDs are not needed
# r7 = Scene Transition Count
# r8 = Major Scene ID
# r9 = Minor Scene ID
# r10, r11 = raw TBU, TBL
#          - r10, r11 make a timestamp counting from epoch in jan 2000 -- unnormalized

OSGlobals  = 0x80000000
Frac = 0x88888889
xBUS_MHz   = 0xF8
xBoot_time = 0x30D8
# clock speed and boot time references

Scene_Controller = 0x80479D30 + 0x10000
xMajor = 0    + (Scene_Controller & 0xFFFF) - 0x10000
xMinor = 3    + (Scene_Controller & 0xFFFF) - 0x10000
xFrame = 0x2C + (Scene_Controller & 0xFFFF) - 0x10000
# performance stat frame counter and scene controller IDs

Scene_transitions = 0x804320CC
# part of archive globals, apparently

xHSD_PerfStat = -0x3FA8
# r13 performance stat time base sample

fScene=1; fRel=2; fBoot=3
rScene=3; rRel=4; rBoot=5; rID=6; rTrans=7; rMajor=8; rMinor=9; rTBU=10; rTBL=11
fTicks=1; fFloor=2; fCeil=3; rCeil=6; rOS=7; rGlobals=8
xBoot=0xC; xRel=0x10

0: mftbu rTBU
mftbl rTBL
mftbu r0
cmpw r0, rTBU
bne- 0b
# get timestamp, correcting for unlikely (but possible) 85-second mark error

mflr r0
stwu sp, -0x20(sp)
stw  r0,  0x20+4(sp)
# callsafe prolog

lis  rOS, OSGlobals@h
lwz  rCeil, xBUS_MHz(rOS)
lis r0, Frac@h
srwi rCeil, rCeil, 2
ori r0, r0, Frac@l # fixed point fraction
mulhwu r3, r0, rCeil # high multiply, to apply fixed point fraction
li r4, 5
bl <fixed_u32.float>
# all casting functions called here have a minimal impact on volatile registers
# - only r0, r3, r4, f0, f1 are affected

fmr fCeil, fTicks
fsubs fFloor, fCeil, fCeil
# fCeil represents a total number of ticks per 'frame', according to BUS speed
# fFloor = 0.0
# - this formats a call/return register pipeline for the <norm> instruction that we can re-use

# <norm> is like a safe division operation that provides a reciprocal and optional floor
#   - f1 = in/out;  f2 and f3 stay the same as a ceiling/floor for sequential division ops

lwz  r3, xBoot_time+0(rOS)
lwz  r4, xBoot_time+4(rOS)
subfc r4, r4, rTBL
subfe r3, r3, rTBU
bl <s64.float>
lfs f0, -0x7FD8(rtoc)
fdiv f1, f1, f0
# boot ticks have been sampled, casted, and normalized into a percentage in f1

stfs f1, xBoot(sp)
bl <float.u32>
mr rBoot, r3
# rBoot is now ready for return, and fBoot is stored in stack frame

lwz r3, xHSD_PerfStat+0(r13)
cmpwi r3, 0
lwz r4, xHSD_PerfStat+4(r13)
beq- 0f
  subfc r4, r4, rTBL
  subfe r3, r3, rTBU
  bl <s64.float>
  lfs f0, -0x7FD8(rtoc)
  fdiv f1, f1, f0
  # Performance stat sample is used to create relative timestamp base
  # - if not available (before first frame of the first scene), then use boot time instead

0:
stfs f1, xRel(sp)
li r3, 20
bl <float.fixed_u32>
#  20-bit fractional component == micro-frame units

stw r3, xRel+4(sp)
lis rGlobals, Scene_Controller@h
lwz r3, xFrame(rGlobals)
bl <u32.float>
lwz rRel, xRel+4(sp)
lfs fRel, xRel(sp)
lfs fBoot, xBoot(sp)
# all timestamps are ready for return:
#   rScene, fScene
#   rRel,   fRel
#   rBoot,  fBoot

lis rTrans, Scene_transitions@h
lbz rMinor, xMinor(rGlobals)
lwz rTrans, (Scene_transitions & 0xFFFF) (rTrans)
lbz rMajor, xMajor(rGlobals)
rlwinm rID, rTrans, 16, 0xFFFF0000
rlwimi rID, rMajor, 8, 0xFF00
rlwimi rID, rMinor, 0, 0xFF
# Scene transition ID has been compiled

_return:
lwz  r0,  0x20+4(sp)
addi sp, sp, 0x20
mtlr r0
blr


<log.mem.info> NTSC 1.02
.include "melee"; punkpc; melee mem
prolog rData, rString, rArg, rID, rMem, rMeta, rFSize, rASize, rReturns, cr, +0x20, xReturns
data.start
  0:  .asciz " MemDesc[%x] -- TYPE: %s %s   DESC: %8x   START: %8x   TOTAL: %\x23\ 8x bytes"
  1:  .asciz " HEAP"
  2:  .asciz "CACHE"
  3:  .asciz "Free     "
  4:  .asciz "Allocated"
  5:  .asciz "   %s   FRAGS: %\x23\ 8x   BIGGEST: %8x (%\x23\ 8x bytes)  TOTAL: %\x23\ 8x bytes"
  6:  .asciz "DRAM"
  7:  .asciz "SRAM"
  8:  .asciz " MemDesc[%x] -- NOT ACTIVE"
  9:  .asciz " MemDesc[%x] -- %s : %8x   START: %8x   SIZE: %\x23 10x   OFFSET: %\x23 10x   QUERY: %8x"
  10: .asciz " Static %5s -- START: %8x   QUERY: %8x   OFFSET: %\x23 10x"
  11: .asciz " (%8x is not a valid query; use a DRAM/SRAM address or a MemDesc ID 0...5)"
  align 2
  data.struct 0, "data.", xID, xHeap, xCache, xFree, xAlloc, xLine, xDRAM, xSRAM, xNotActive, xAddr, xStatic, xBad

data.end rData
mr rArg, r3
bl <mem.info>
cmpwi cr2, rArg, 0
mr. rMem, mem.info.rMem
mr rID, mem.info.rID
bge- cr2, _handle_ID

  _handle_addr:
  bt+ mem.info.bInRegion, _mem_addr
    cmpwi cr3, mem.info.rStatic, 0
    blt cr3, _static_addr

      _bad_addr:
      addi r3, rData, data.xBad
      mr r4, rArg
      b _final_print
      # print invalid query message if no information is returned from mem.info

      _static_addr:
      mr r5, mem.info.rStatic
      mr r4, mem.info.rString
      addi r3, rData, data.xStatic
      mr r6, rArg
      sub r7, r6, r5
      b _final_print
      # print static address info if query address couldn't be found in a managed memory region

      _mem_addr:
      sub r9, rArg, mem.info.rStart
      #mr r6, mem.info.rCache # -- already in place
      addi r5, rData, data.xCache
      bf+ mem.info.bIsHeap, 0f
        addi r5, rData, data.xHeap
        mr r6, mem.info.rHeap

      0:
      mr r7, mem.info.rStart
      mr r8, mem.info.rSize
      addi r3, rData, data.xAddr
      mr r4, rID
      mr r10, rArg
      b _final_print
      # print allocation/fragment information if

_handle_ID:
blt+ _memdesc_ID

  _inactive_ID:
  cmpwi rID, 5
  bgt- _bad_addr
  mr r4, rID
  addi r3, rData, data.xNotActive
  b _final_print
  # print about inactive region if ID is given but memdesc isn't found


  _memdesc_ID:
  regs (mem.info.rFCount), +1, rFCount, rFBig, rFTotal, rACount, rABig, rATotal
  # create aliases in this namespace for some mem.info.* returns

  cmpwi cr2, rFBig, 0
  cmpwi cr3, rABig, 0
  mr rFSize, rFBig
  mr rASize, rABig
  addi rReturns, sp, sp.xReturns
  stswi rFCount, rReturns, 6<<2
  # temporarily store finalized info about free and allocated fragments
  bt- mem.info.bIsHeap, _heap_ID

    _cache_ID:
    addi rString, rData, data.xCache
    bge- cr3, 0f; lwz rASize, CacheMeta.xSize(rABig); 0:
    b _print_ID

    _heap_ID:
    addi rString, rData, data.xHeap
    bge- cr2, 0f; lwz rFSize, HeapMeta.xSize(rFBig); 0:
    bge- cr3, 0f; lwz rASize, HeapMeta.xSize(rABig); 0:

  _print_ID:
  mr r7, mem.info.rMem
  lwz r8, MemDesc.xStart(r7)
  lwz r9, MemDesc.xSize(r7)
  addi r5, rData, data.xSRAM
  bf+ mem.info.bIsARAM, 0f; addi r5, rData, data.xDRAM; 0:
  mr r6, rString
  mr r4, rID
  addi r3, rData, data.xID
  bl <log.print>
  addi r3, rData, data.xLine
  addi r4, rData, data.xFree
  lswi r5, rReturns, 3<<2
  mr r8, r7
  mr r7, rFSize
  bl <log.print>
  addi r3, rData, data.xLine
  addi rReturns, rReturns, 3<<2
  addi r4, rData, data.xAlloc
  lswi r5, rReturns, 3<<2
  mr r8, r7
  mr r7, rASize

  _final_print:
  bl <log.print>
  bl <log.nl>

_return:
epilog
blr
